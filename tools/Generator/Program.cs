using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace Generator
{
    class Program
    {
        static async Task Main(string[] args)
        {
            var workspaceRoot = GetWorkspaceRoot(Directory.GetCurrentDirectory());
            var schemaRoot = Path.Combine(workspaceRoot, "contracts", "schemas");
            var outputDir = Path.Combine(workspaceRoot, "generated", "csharp");
            var outputFile = Path.Combine(outputDir, "MessagingContracts.cs");

            Console.WriteLine("Cleaning up existing generated files...");
            if (Directory.Exists(outputDir))
            {
                var filesToDelete = Directory.EnumerateFiles(outputDir, "*.cs", SearchOption.AllDirectories);
                foreach (var file in filesToDelete)
                {
                    File.Delete(file);
                }
            }
            else
            {
                Directory.CreateDirectory(outputDir);
            }

            var generator = new ManualCSharpGenerator(schemaRoot);
            var code = await generator.GenerateAsync();

            await File.WriteAllTextAsync(outputFile, code);

            Console.WriteLine($"✓ C# contract generation complete.");
            Console.WriteLine($"✓ All contracts written to {outputFile}");
        }

        static string GetWorkspaceRoot(string currentDir)
        {
            var dir = new DirectoryInfo(currentDir);
            while (dir != null && !dir.GetFiles("*.sln").Any())
            {
                dir = dir.Parent;
            }
            return dir?.FullName ?? throw new DirectoryNotFoundException("Could not find workspace root containing a .sln file.");
        }
    }

    public class ManualCSharpGenerator
    {
        private readonly string _schemaRoot;

        public ManualCSharpGenerator(string schemaRoot)
        {
            _schemaRoot = schemaRoot;
        }

        public async Task<string> GenerateAsync()
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("//----------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"//     Generated on {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("//----------------------");
            sb.AppendLine();
                    sb.AppendLine("using System.Text.Json.Serialization;");
                    sb.AppendLine();
                    sb.AppendLine("namespace Maliev.MessagingContracts");
                    sb.AppendLine("{");
            // Generate BaseMessage first
            Console.WriteLine("Generating BaseMessage...");
            await GenerateBaseMessage(sb);

            // Generate enum for MessageType
            GenerateMessageTypeEnum(sb);

            // Collect and generate message contracts
            var messageSchemaFiles = new List<string>();
            foreach (var domainDir in new[] { "commands", "orders", "payments", "customers", "shared" })
            {
                var domainPath = Path.Combine(_schemaRoot, domainDir);
                if (Directory.Exists(domainPath))
                {
                    var files = Directory.GetFiles(domainPath, "*.json", SearchOption.AllDirectories);
                    // Filter out only the exact base schemas, not anything ending with them
                    var filtered = files.Where(f => 
                        !f.EndsWith("base-message.json", StringComparison.OrdinalIgnoreCase) && 
                        !f.EndsWith("envelope.json", StringComparison.OrdinalIgnoreCase) &&
                        !Path.GetFileName(f).Equals("command.json", StringComparison.OrdinalIgnoreCase) &&
                        !Path.GetFileName(f).Equals("domain-event.json", StringComparison.OrdinalIgnoreCase) &&
                        !Path.GetFileName(f).Equals("integration-event.json", StringComparison.OrdinalIgnoreCase)
                    ).ToList();
                    messageSchemaFiles.AddRange(filtered);
                }
            }

            foreach (var file in messageSchemaFiles.OrderBy(f => f))
            {
                var className = GetClassName(file);
                Console.WriteLine($"Generating {className}...");
                await GenerateMessageClass(sb, file, className);
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        private async Task GenerateBaseMessage(StringBuilder sb)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// The base structure that all Maliev messaging contracts MUST adhere to.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public record BaseMessage(");
            sb.AppendLine("        [property: JsonPropertyName(\"messageId\")] System.Guid MessageId,");
            sb.AppendLine("        [property: JsonPropertyName(\"messageName\")] string MessageName,");
            sb.AppendLine("        [property: JsonPropertyName(\"messageType\")] MessageType MessageType,");
            sb.AppendLine("        [property: JsonPropertyName(\"messageVersion\")] string MessageVersion,");
            sb.AppendLine("        [property: JsonPropertyName(\"publishedBy\")] string PublishedBy,");
            sb.AppendLine("        [property: JsonPropertyName(\"consumedBy\")] System.Collections.Generic.IReadOnlyList<string> ConsumedBy,");
            sb.AppendLine("        [property: JsonPropertyName(\"correlationId\")] System.Guid CorrelationId,");
            sb.AppendLine("        [property: JsonPropertyName(\"causationId\")] System.Guid? CausationId,");
            sb.AppendLine("        [property: JsonPropertyName(\"occurredAtUtc\")] System.DateTimeOffset OccurredAtUtc,");
            sb.AppendLine("        [property: JsonPropertyName(\"isPublic\")] bool IsPublic");
            sb.AppendLine("    );");
            sb.AppendLine();
        }

        private void GenerateMessageTypeEnum(StringBuilder sb)
        {
            sb.AppendLine("    [JsonConverter(typeof(JsonStringEnumConverter))]");
            sb.AppendLine("    public enum MessageType");
            sb.AppendLine("    {");
            sb.AppendLine("        Command,");
            sb.AppendLine("        Event,");
            sb.AppendLine("        Request,");
            sb.AppendLine("        Response");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private async Task GenerateMessageClass(StringBuilder sb, string schemaFile, string className)
        {
            var schemaJson = await File.ReadAllTextAsync(schemaFile);
            var schema = JsonDocument.Parse(schemaJson);
            var root = schema.RootElement;

            // Get description/title
            if (root.TryGetProperty("description", out var desc))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {desc.GetString()}");
                sb.AppendLine("    /// </summary>");
            }
            else if (root.TryGetProperty("title", out var title))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {title.GetString()}");
                sb.AppendLine("    /// </summary>");
            }

            // Check if this inherits from BaseMessage
            bool inheritsFromBase = false;
            if (root.TryGetProperty("allOf", out var allOf))
            {
                foreach (var item in allOf.EnumerateArray())
                {
                    if (item.TryGetProperty("$ref", out var refProp))
                    {
                        var refValue = refProp.GetString();
                        if (refValue != null && refValue.Contains("base-message"))
                        {
                            inheritsFromBase = true;
                            break;
                        }
                    }
                }
            }

            if (inheritsFromBase)
            {
                // Generate as derived class from BaseMessage
                await GenerateDerivedMessage(sb, root, className);
            }
            else
            {
                // Generate as standalone class
                await GenerateStandaloneMessage(sb, root, className);
            }

            sb.AppendLine();
        }

        private async Task GenerateDerivedMessage(StringBuilder sb, JsonElement root, string className)
        {
            // Extract the payload schema and generate nested types if needed
            var properties = new List<(string Name, string JsonName, string Type, bool Required)>();
            var requiredProps = new HashSet<string>();

            if (root.TryGetProperty("required", out var reqArray))
            {
                foreach (var req in reqArray.EnumerateArray())
                {
                    requiredProps.Add(req.GetString() ?? "");
                }
            }

            if (root.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;

                    // Check if this is a payload object and generate nested type
                    string propType;
                    if (prop.Value.TryGetProperty("type", out var typeEl) &&
                        typeEl.GetString() == "object" &&
                        prop.Value.TryGetProperty("properties", out var nestedProps))
                    {
                        // Generate nested record
                        var nestedTypeName = propName.Equals("Payload", StringComparison.OrdinalIgnoreCase) 
                            ? $"{className}Payload" 
                            : $"{className}{propName}";
                        
                        GenerateNestedRecord(sb, nestedTypeName, prop.Value, className);
                        propType = nestedTypeName;
                    }
                    else if (prop.Value.TryGetProperty("type", out var arrayType) &&
                             arrayType.GetString() == "array" &&
                             prop.Value.TryGetProperty("items", out var itemsEl) &&
                             itemsEl.TryGetProperty("type", out var itemTypeEl) &&
                             itemTypeEl.GetString() == "object")
                    {
                        // Generate record for array items
                        var itemTypeName = $"{className}{propName}Item";
                        GenerateNestedRecord(sb, itemTypeName, itemsEl, className);
                        propType = $"System.Collections.Generic.IReadOnlyList<{itemTypeName}>";
                    }
                    else
                    {
                        propType = GetCSharpType(prop.Value, propName);
                    }

                    var isRequired = requiredProps.Contains(prop.Name);
                    properties.Add((propName, jsonName, propType, isRequired));
                }
            }

            // Generate the message record that extends BaseMessage
            sb.Append($"    public record {className}(");

            // Base class parameters first - NO attributes here because they hide/override base properties incorrectly if attributed as property
            var baseParams = new[]
            {
                "System.Guid MessageId",
                "string MessageName",
                "MessageType MessageType",
                "string MessageVersion",
                "string PublishedBy",
                "System.Collections.Generic.IReadOnlyList<string> ConsumedBy",
                "System.Guid CorrelationId",
                "System.Guid? CausationId",
                "System.DateTimeOffset OccurredAtUtc",
                "bool IsPublic"
            };

            var allParams = baseParams.ToList();
            foreach (var (Name, JsonName, Type, _) in properties)
            {
                allParams.Add($"[property: JsonPropertyName(\"{JsonName}\")] {Type} {Name}");
            }

            sb.AppendLine();
            for (int i = 0; i < allParams.Count; i++)
            {
                sb.Append($"        {allParams[i]}");
                if (i < allParams.Count - 1)
                {
                    sb.AppendLine(",");
                }
            }
            sb.AppendLine();
            sb.Append("    ) : BaseMessage(MessageId, MessageName, MessageType, MessageVersion, PublishedBy, ConsumedBy, CorrelationId, CausationId, OccurredAtUtc, IsPublic);");
            sb.AppendLine();
        }

        private void GenerateNestedRecord(StringBuilder sb, string typeName, JsonElement schema, string parentClassName)
        {
            var properties = new List<(string Name, string JsonName, string Type)>();

            if (schema.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;
                    string propType;

                    if (prop.Value.TryGetProperty("type", out var typeEl) &&
                        typeEl.GetString() == "object" &&
                        prop.Value.TryGetProperty("properties", out var nestedProps))
                    {
                        var nestedTypeName = $"{typeName}{propName}";
                        GenerateNestedRecord(sb, nestedTypeName, prop.Value, parentClassName);
                        propType = nestedTypeName;
                    }
                    else if (prop.Value.TryGetProperty("type", out var arrayType) &&
                             arrayType.GetString() == "array" &&
                             prop.Value.TryGetProperty("items", out var itemsEl) &&
                             itemsEl.TryGetProperty("type", out var itemTypeEl) &&
                             itemTypeEl.GetString() == "object")
                    {
                        var itemTypeName = $"{typeName}{propName}Item";
                        GenerateNestedRecord(sb, itemTypeName, itemsEl, parentClassName);
                        propType = $"System.Collections.Generic.IReadOnlyList<{itemTypeName}>";
                    }
                    else
                    {
                        propType = GetCSharpType(prop.Value, propName);
                    }

                    properties.Add((propName, jsonName, propType));
                }
            }

            sb.Append($"    public record {typeName}(");
            for (int i = 0; i < properties.Count; i++)
            {
                sb.Append($"[property: JsonPropertyName(\"{properties[i].JsonName}\")] {properties[i].Type} {properties[i].Name}");
                if (i < properties.Count - 1)
                {
                    sb.Append(", ");
                }
            }
            sb.AppendLine(");");
            sb.AppendLine();
        }

        private async Task GenerateStandaloneMessage(StringBuilder sb, JsonElement root, string className)
        {
            var properties = new List<(string Name, string JsonName, string Type)>();

            if (root.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;
                    var propType = GetCSharpType(prop.Value, propName);
                    properties.Add((propName, jsonName, propType));
                }
            }

            sb.Append($"    public record {className}(");
            for (int i = 0; i < properties.Count; i++)
            {
                sb.Append($"[property: JsonPropertyName(\"{properties[i].JsonName}\")] {properties[i].Type} {properties[i].Name}");
                if (i < properties.Count - 1)
                {
                    sb.Append(", ");
                }
            }
            sb.AppendLine(");");
        }

        private string GetCSharpType(JsonElement propertySchema, string propertyName = "")
        {
            if (propertySchema.TryGetProperty("type", out var typeProp))
            {
                var typeStr = typeProp.GetString();
                if (typeStr == "object")
                {
                    // Check if it has properties (it's a complex type)
                    if (propertySchema.TryGetProperty("properties", out var props))
                    {
                        // This is a nested type - for payloads, we'll use a descriptive name
                        if (propertyName.Equals("Payload", StringComparison.OrdinalIgnoreCase))
                        {
                            // Return a generic payload record type
                            // We'll enhance this later to generate nested records
                            return "object";
                        }
                        return "object";
                    }
                    return "object";
                }
                else if (typeStr == "string")
                {
                    if (propertySchema.TryGetProperty("format", out var format))
                    {
                        var formatStr = format.GetString();
                        if (formatStr == "uuid") return "System.Guid";
                        if (formatStr == "date-time") return "System.DateTimeOffset";
                        if (formatStr == "email") return "string";
                    }
                    return "string";
                }
                else if (typeStr == "number")
                {
                    return "double";
                }
                else if (typeStr == "integer")
                {
                    return "int";
                }
                else if (typeStr == "boolean")
                {
                    return "bool";
                }
                else if (typeStr == "array")
                {
                    if (propertySchema.TryGetProperty("items", out var items))
                    {
                        var itemType = GetCSharpType(items);
                        return $"System.Collections.Generic.IReadOnlyList<{itemType}>";
                    }
                    return "System.Collections.Generic.IReadOnlyList<object>";
                }
            }

            return "object";
        }

        private string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input)) return input;

            // Handle kebab-case and snake_case
            if (input.Contains('-') || input.Contains('_'))
            {
                var words = input.Split(new[] { '-', '_' }, StringSplitOptions.RemoveEmptyEntries);
                return string.Join("", words.Select(w =>
                    CultureInfo.InvariantCulture.TextInfo.ToTitleCase(w.ToLower())));
            }

            // Handle camelCase - just capitalize the first letter
            return char.ToUpper(input[0]) + input.Substring(1);
        }

        private string GetClassName(string filePath)
        {
            var baseName = Path.GetFileNameWithoutExtension(filePath);
            return CultureInfo.InvariantCulture.TextInfo.ToTitleCase(baseName.Replace('-', ' ')).Replace(" ", "");
        }
    }
}
