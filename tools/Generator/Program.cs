using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace Generator
{
    class Program
    {
        static async Task Main(string[] args)
        {
            var workspaceRoot = GetWorkspaceRoot(Directory.GetCurrentDirectory());
            var schemaRoot = Path.Combine(workspaceRoot, "contracts", "schemas");
            var outputDir = Path.Combine(workspaceRoot, "generated", "csharp", "Contracts");
            var outputFile = Path.Combine(outputDir, "MessagingContracts.cs");

            Console.WriteLine("Cleaning up existing generated files...");
            if (Directory.Exists(outputDir))
            {
                var filesToDelete = Directory.EnumerateFiles(outputDir, "*.cs", SearchOption.AllDirectories);
                foreach (var file in filesToDelete)
                {
                    File.Delete(file);
                }
            }
            else
            {
                Directory.CreateDirectory(outputDir);
            }

            var generator = new ManualCSharpGenerator(schemaRoot);
            var code = await generator.GenerateAsync();

            if (File.Exists(outputFile))
            {
                var existingCode = await File.ReadAllTextAsync(outputFile);
                if (existingCode == code)
                {
                    Console.WriteLine("✓ No changes detected. Generation skipped.");
                    return;
                }
            }

            await File.WriteAllTextAsync(outputFile, code);

            Console.WriteLine($"✓ C# contract generation complete.");
            Console.WriteLine($"✓ All contracts written to {outputFile}");
        }

        static string GetWorkspaceRoot(string currentDir)
        {
            var dir = new DirectoryInfo(currentDir);
            while (dir != null && !dir.GetFiles("*.sln").Any())
            {
                dir = dir.Parent;
            }
            return dir?.FullName ?? throw new DirectoryNotFoundException("Could not find workspace root containing a .sln file.");
        }
    }

    public class ManualCSharpGenerator
    {
        private readonly string _schemaRoot;

        public ManualCSharpGenerator(string schemaRoot)
        {
            _schemaRoot = schemaRoot;
        }

        public async Task<string> GenerateAsync()
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("//----------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     Generated from schemas");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("//----------------------");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine();
            sb.AppendLine("namespace Maliev.MessagingContracts.Generated");
            sb.AppendLine("{");            // Generate BaseMessage first
            Console.WriteLine("Generating BaseMessage...");
            await GenerateBaseMessage(sb);

            // Generate enum for MessageType
            GenerateMessageTypeEnum(sb);

            // Collect and generate message contracts
            var messageSchemaFiles = new List<string>();
            foreach (var domainDir in new[] { "commands", "orders", "payments", "customers", "iam", "shared", "career", "compensation", "compliance", "employee", "leave", "lifecycle", "performance", "chatbot", "invoices", "quotations", "purchase-orders", "receipts", "materials", "suppliers", "auth", "uploads", "pdf", "geometry" })
            {
                var domainPath = Path.Combine(_schemaRoot, domainDir);
                if (Directory.Exists(domainPath))
                {
                    var files = Directory.GetFiles(domainPath, "*.json", SearchOption.AllDirectories);
                    // Filter out only the exact base schemas, not anything ending with them
                    var filtered = files.Where(f =>
                        !f.EndsWith("base-message.json", StringComparison.OrdinalIgnoreCase) &&
                        !f.EndsWith("envelope.json", StringComparison.OrdinalIgnoreCase) &&
                        !Path.GetFileName(f).Equals("command.json", StringComparison.OrdinalIgnoreCase) &&
                        !Path.GetFileName(f).Equals("domain-event.json", StringComparison.OrdinalIgnoreCase) &&
                        !Path.GetFileName(f).Equals("integration-event.json", StringComparison.OrdinalIgnoreCase)
                    ).ToList();
                    messageSchemaFiles.AddRange(filtered);
                }
            }

            foreach (var file in messageSchemaFiles.OrderBy(f => f))
            {
                var schemaJson = await File.ReadAllTextAsync(file);
                var schema = JsonDocument.Parse(schemaJson);
                var root = schema.RootElement;

                // Check if this file contains a "definitions" object with multiple events
                if (root.TryGetProperty("definitions", out var definitions))
                {
                    // Generate a class for each definition
                    foreach (var definition in definitions.EnumerateObject())
                    {
                        var className = definition.Name;
                        Console.WriteLine($"Generating {className}...");
                        await GenerateMessageClassFromDefinition(sb, definition.Value, className);
                    }
                }
                else
                {
                    // Generate as a single message class (existing behavior)
                    var className = GetClassName(file);
                    Console.WriteLine($"Generating {className}...");
                    await GenerateMessageClass(sb, file, className);
                }
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        private async Task GenerateBaseMessage(StringBuilder sb)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// The base structure that all Maliev messaging contracts MUST adhere to.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"MessageId\">Unique identifier for the message.</param>");
            sb.AppendLine("    /// <param name=\"MessageName\">Descriptive name of the message.</param>");
            sb.AppendLine("    /// <param name=\"MessageType\">The type of message (Command, Event, etc.).</param>");
            sb.AppendLine("    /// <param name=\"MessageVersion\">Semantic version of the message contract.</param>");
            sb.AppendLine("    /// <param name=\"PublishedBy\">The service that published the message.</param>");
            sb.AppendLine("    /// <param name=\"ConsumedBy\">List of services intended to consume the message.</param>");
            sb.AppendLine("    /// <param name=\"CorrelationId\">Id used to correlate related messages across a flow.</param>");
            sb.AppendLine("    /// <param name=\"CausationId\">Id of the message that caused this one.</param>");
            sb.AppendLine("    /// <param name=\"OccurredAtUtc\">Timestamp of when the message occurred.</param>");
            sb.AppendLine("    /// <param name=\"IsPublic\">True if the message is intended for external systems.</param>");
            sb.AppendLine("    public record BaseMessage(");
            sb.AppendLine("        [property: JsonPropertyName(\"messageId\")] System.Guid MessageId,");
            sb.AppendLine("        [property: JsonPropertyName(\"messageName\")] string MessageName,");
            sb.AppendLine("        [property: JsonPropertyName(\"messageType\")] MessageType MessageType,");
            sb.AppendLine("        [property: JsonPropertyName(\"messageVersion\")] string MessageVersion,");
            sb.AppendLine("        [property: JsonPropertyName(\"publishedBy\")] string PublishedBy,");
            sb.AppendLine("        [property: JsonPropertyName(\"consumedBy\")] System.Collections.Generic.IReadOnlyList<string> ConsumedBy,");
            sb.AppendLine("        [property: JsonPropertyName(\"correlationId\")] System.Guid CorrelationId,");
            sb.AppendLine("        [property: JsonPropertyName(\"causationId\")] System.Guid? CausationId,");
            sb.AppendLine("        [property: JsonPropertyName(\"occurredAtUtc\")] System.DateTimeOffset OccurredAtUtc,");
            sb.AppendLine("        [property: JsonPropertyName(\"isPublic\")] bool IsPublic");
            sb.AppendLine("    );");
            sb.AppendLine();
        }

        private void GenerateMessageTypeEnum(StringBuilder sb)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Defines the types of messages supported in the MALIEV messaging system.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    [JsonConverter(typeof(JsonStringEnumConverter))]");
            sb.AppendLine("    public enum MessageType");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>Represents a request to perform an action.</summary>");
            sb.AppendLine("        Command,");
            sb.AppendLine("        /// <summary>Represents notification of a fact that has occurred.</summary>");
            sb.AppendLine("        Event,");
            sb.AppendLine("        /// <summary>Represents a request for information.</summary>");
            sb.AppendLine("        Request,");
            sb.AppendLine("        /// <summary>Represents a response to a request.</summary>");
            sb.AppendLine("        Response");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private async Task GenerateMessageClass(StringBuilder sb, string schemaFile, string className)
        {
            var schemaJson = await File.ReadAllTextAsync(schemaFile);
            var schema = JsonDocument.Parse(schemaJson);
            var root = schema.RootElement;

            // Get description/title
            if (root.TryGetProperty("description", out var desc))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {desc.GetString()}");
                sb.AppendLine("    /// </summary>");
            }
            else if (root.TryGetProperty("title", out var title))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {title.GetString()}");
                sb.AppendLine("    /// </summary>");
            }

            // Check if this inherits from BaseMessage
            bool inheritsFromBase = false;
            if (root.TryGetProperty("allOf", out var allOf))
            {
                foreach (var item in allOf.EnumerateArray())
                {
                    if (item.TryGetProperty("$ref", out var refProp))
                    {
                        var refValue = refProp.GetString();
                        if (refValue != null && refValue.Contains("base-message"))
                        {
                            inheritsFromBase = true;
                            break;
                        }
                    }
                }
            }

            if (inheritsFromBase)
            {
                // Generate as derived class from BaseMessage
                await GenerateDerivedMessage(sb, root, className);
            }
            else
            {
                // Generate as standalone class
                await GenerateStandaloneMessage(sb, root, className);
            }

            sb.AppendLine();
        }

        private async Task GenerateMessageClassFromDefinition(StringBuilder sb, JsonElement definition, string className)
        {
            // Get description from definition
            string description = "";
            if (definition.TryGetProperty("description", out var desc))
            {
                description = desc.GetString() ?? "";
            }

            GeneratePayloadRecord(sb, definition, $"{className}Payload");

            // Now generate the full event message that derives from BaseMessage
            if (!string.IsNullOrEmpty(description))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {description}");
                sb.AppendLine("    /// </summary>");
            }
            sb.AppendLine("    /// <param name=\"Payload\">The specific data associated with this message.</param>");
            sb.AppendLine($"    public record {className}(");

            // Base class parameters first
            var baseParams = new[]
            {
                "System.Guid MessageId",
                "string MessageName",
                "MessageType MessageType",
                "string MessageVersion",
                "string PublishedBy",
                "System.Collections.Generic.IReadOnlyList<string> ConsumedBy",
                "System.Guid CorrelationId",
                "System.Guid? CausationId",
                "System.DateTimeOffset OccurredAtUtc",
                "bool IsPublic"
            };

            var allParams = baseParams.ToList();
            allParams.Add($"[property: JsonPropertyName(\"payload\")] {className}Payload Payload");

            sb.AppendLine();
            for (int i = 0; i < allParams.Count; i++)
            {
                sb.Append($"        {allParams[i]}");
                if (i < allParams.Count - 1)
                {
                    sb.AppendLine(",");
                }
            }
            sb.AppendLine();
            sb.Append("    ) : BaseMessage(MessageId, MessageName, MessageType, MessageVersion, PublishedBy, ConsumedBy, CorrelationId, CausationId, OccurredAtUtc, IsPublic);");
            sb.AppendLine();
            sb.AppendLine();
        }

        private void GeneratePayloadRecord(StringBuilder sb, JsonElement schema, string typeName)
        {
            var properties = new List<(string Name, string JsonName, string Type, string Description)>();

            if (schema.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;
                    string propType;
                    string propDescription = "";

                    if (prop.Value.TryGetProperty("description", out var pDesc))
                    {
                        propDescription = pDesc.GetString() ?? "";
                    }

                    // Extract the actual type string, handling nullable arrays
                    var typeStr = GetTypeString(prop.Value);

                    if (typeStr == "object" &&
                        prop.Value.TryGetProperty("properties", out var nestedProps))
                    {
                        var nestedTypeName = $"{typeName}{propName}";
                        GeneratePayloadRecord(sb, prop.Value, nestedTypeName);
                        propType = nestedTypeName;
                    }
                    else if (typeStr == "array" &&
                             prop.Value.TryGetProperty("items", out var itemsEl))
                    {
                        var itemTypeStr = GetTypeString(itemsEl);
                        if (itemTypeStr == "object")
                        {
                            var itemTypeName = $"{typeName}{propName}Item";
                            GeneratePayloadRecord(sb, itemsEl, itemTypeName);
                            propType = $"System.Collections.Generic.IReadOnlyList<{itemTypeName}>";
                        }
                        else
                        {
                            propType = GetCSharpType(prop.Value, propName);
                        }
                    }
                    else
                    {
                        propType = GetCSharpType(prop.Value, propName);
                    }

                    properties.Add((propName, jsonName, propType, propDescription));
                }
            }

            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Payload data for {typeName.Replace("Payload", "")}.");
            sb.AppendLine("    /// </summary>");
            foreach (var prop in properties)
            {
                if (!string.IsNullOrEmpty(prop.Description))
                {
                    sb.AppendLine($"    /// <param name=\"{prop.Name}\">{prop.Description}</param>");
                }
            }

            sb.Append($"    public record {typeName}(");
            for (int i = 0; i < properties.Count; i++)
            {
                sb.Append($"[property: JsonPropertyName(\"{properties[i].JsonName}\")] {properties[i].Type} {properties[i].Name}");
                if (i < properties.Count - 1)
                {
                    sb.Append(", ");
                }
            }
            sb.AppendLine(");");
            sb.AppendLine();
        }

        private string GetTypeString(JsonElement element)
        {
            if (element.TryGetProperty("type", out var typeProp))
            {
                if (typeProp.ValueKind == JsonValueKind.Array)
                {
                    return typeProp.EnumerateArray()
                        .Select(t => t.GetString())
                        .Where(t => t != null)
                        .FirstOrDefault(t => t != "null") ?? "object";
                }
                return typeProp.GetString() ?? "object";
            }
            return "object";
        }


        private async Task GenerateDerivedMessage(StringBuilder sb, JsonElement root, string className)
        {
            // Extract the payload schema and generate nested types if needed
            var properties = new List<(string Name, string JsonName, string Type, bool Required, string Description)>();
            var requiredProps = new HashSet<string>();

            if (root.TryGetProperty("required", out var reqArray))
            {
                foreach (var req in reqArray.EnumerateArray())
                {
                    requiredProps.Add(req.GetString() ?? "");
                }
            }

            if (root.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;
                    string propDescription = "";
                    if (prop.Value.TryGetProperty("description", out var pDesc))
                    {
                        propDescription = pDesc.GetString() ?? "";
                    }

                    // Check if this is a payload object and generate nested type
                    string propType;
                    if (prop.Value.TryGetProperty("type", out var typeEl) &&
                        typeEl.GetString() == "object" &&
                        prop.Value.TryGetProperty("properties", out var nestedProps))
                    {
                        // Generate nested record
                        var nestedTypeName = propName.Equals("Payload", StringComparison.OrdinalIgnoreCase)
                            ? $"{className}Payload"
                            : $"{className}{propName}";

                        GenerateNestedRecord(sb, nestedTypeName, prop.Value, className);
                        propType = nestedTypeName;
                    }
                    else if (prop.Value.TryGetProperty("type", out var arrayType) &&
                             arrayType.GetString() == "array" &&
                             prop.Value.TryGetProperty("items", out var itemsEl) &&
                             itemsEl.TryGetProperty("type", out var itemTypeEl) &&
                             itemTypeEl.GetString() == "object")
                    {
                        // Generate record for array items
                        var itemTypeName = $"{className}{propName}Item";
                        GenerateNestedRecord(sb, itemTypeName, itemsEl, className);
                        propType = $"System.Collections.Generic.IReadOnlyList<{itemTypeName}>";
                    }
                    else
                    {
                        propType = GetCSharpType(prop.Value, propName);
                    }

                    var isRequired = requiredProps.Contains(prop.Name);
                    properties.Add((propName, jsonName, propType, isRequired, propDescription));
                }
            }

            // Generate the message record that extends BaseMessage
            foreach (var prop in properties)
            {
                if (!string.IsNullOrEmpty(prop.Description))
                {
                    sb.AppendLine($"    /// <param name=\"{prop.Name}\">{prop.Description}</param>");
                }
            }
            sb.Append($"    public record {className}(");

            // Base class parameters first
            var baseParams = new[]
            {
                "System.Guid MessageId",
                "string MessageName",
                "MessageType MessageType",
                "string MessageVersion",
                "string PublishedBy",
                "System.Collections.Generic.IReadOnlyList<string> ConsumedBy",
                "System.Guid CorrelationId",
                "System.Guid? CausationId",
                "System.DateTimeOffset OccurredAtUtc",
                "bool IsPublic"
            };

            var allParams = baseParams.ToList();
            foreach (var (Name, JsonName, Type, _, _) in properties)
            {
                allParams.Add($"[property: JsonPropertyName(\"{JsonName}\")] {Type} {Name}");
            }

            sb.AppendLine();
            for (int i = 0; i < allParams.Count; i++)
            {
                sb.Append($"        {allParams[i]}");
                if (i < allParams.Count - 1)
                {
                    sb.AppendLine(",");
                }
            }
            sb.AppendLine();
            sb.Append("    ) : BaseMessage(MessageId, MessageName, MessageType, MessageVersion, PublishedBy, ConsumedBy, CorrelationId, CausationId, OccurredAtUtc, IsPublic);");
            sb.AppendLine();
        }

        private void GenerateNestedRecord(StringBuilder sb, string typeName, JsonElement schema, string parentClassName)
        {
            var properties = new List<(string Name, string JsonName, string Type, string Description)>();

            if (schema.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;
                    string propType;
                    string propDescription = "";
                    if (prop.Value.TryGetProperty("description", out var pDesc))
                    {
                        propDescription = pDesc.GetString() ?? "";
                    }

                    if (prop.Value.TryGetProperty("type", out var typeEl) &&
                        typeEl.ValueKind == JsonValueKind.String &&
                        typeEl.GetString() == "object" &&
                        prop.Value.TryGetProperty("properties", out var nestedProps))
                    {
                        var nestedTypeName = $"{typeName}{propName}";
                        GenerateNestedRecord(sb, nestedTypeName, prop.Value, parentClassName);
                        propType = nestedTypeName;
                    }
                    else if (prop.Value.TryGetProperty("type", out var arrayType) &&
                             arrayType.ValueKind == JsonValueKind.String &&
                             arrayType.GetString() == "array" &&
                             prop.Value.TryGetProperty("items", out var itemsEl) &&
                             itemsEl.TryGetProperty("type", out var itemTypeEl) &&
                             itemTypeEl.ValueKind == JsonValueKind.String &&
                             itemTypeEl.GetString() == "object")
                    {
                        var itemTypeName = $"{typeName}{propName}Item";
                        GenerateNestedRecord(sb, itemTypeName, itemsEl, parentClassName);
                        propType = $"System.Collections.Generic.IReadOnlyList<{itemTypeName}>";
                    }
                    else
                    {
                        propType = GetCSharpType(prop.Value, propName);
                    }

                    properties.Add((propName, jsonName, propType, propDescription));
                }
            }

            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Nested data for {typeName}.");
            sb.AppendLine("    /// </summary>");
            foreach (var prop in properties)
            {
                if (!string.IsNullOrEmpty(prop.Description))
                {
                    sb.AppendLine($"    /// <param name=\"{prop.Name}\">{prop.Description}</param>");
                }
            }
            sb.Append($"    public record {typeName}(");
            for (int i = 0; i < properties.Count; i++)
            {
                sb.Append($"[property: JsonPropertyName(\"{properties[i].JsonName}\")] {properties[i].Type} {properties[i].Name}");
                if (i < properties.Count - 1)
                {
                    sb.Append(", ");
                }
            }
            sb.AppendLine(");");
            sb.AppendLine();
        }

        private async Task GenerateStandaloneMessage(StringBuilder sb, JsonElement root, string className)
        {
            var properties = new List<(string Name, string JsonName, string Type, string Description)>();

            if (root.TryGetProperty("properties", out var props))
            {
                foreach (var prop in props.EnumerateObject())
                {
                    var propName = ToPascalCase(prop.Name);
                    var jsonName = prop.Name;
                    string propDescription = "";
                    if (prop.Value.TryGetProperty("description", out var pDesc))
                    {
                        propDescription = pDesc.GetString() ?? "";
                    }
                    var propType = GetCSharpType(prop.Value, propName);
                    properties.Add((propName, jsonName, propType, propDescription));
                }
            }

            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Standalone message {className}.");
            sb.AppendLine("    /// </summary>");
            foreach (var prop in properties)
            {
                if (!string.IsNullOrEmpty(prop.Description))
                {
                    sb.AppendLine($"    /// <param name=\"{prop.Name}\">{prop.Description}</param>");
                }
            }
            sb.Append($"    public record {className}(");
            for (int i = 0; i < properties.Count; i++)
            {
                sb.Append($"[property: JsonPropertyName(\"{properties[i].JsonName}\")] {properties[i].Type} {properties[i].Name}");
                if (i < properties.Count - 1)
                {
                    sb.Append(", ");
                }
            }
            sb.AppendLine(");");
        }

        private string GetCSharpType(JsonElement propertySchema, string propertyName = "")
        {
            if (propertySchema.TryGetProperty("type", out var typeProp))
            {
                string typeStr;
                bool isNullable = false;

                // Handle type arrays like ["string", "null"]
                if (typeProp.ValueKind == JsonValueKind.Array)
                {
                    var types = typeProp.EnumerateArray()
                        .Select(t => t.GetString())
                        .Where(t => t != null)
                        .ToList();
                    isNullable = types.Contains("null");
                    typeStr = types.FirstOrDefault(t => t != "null") ?? "object";
                }
                else
                {
                    typeStr = typeProp.GetString() ?? "object";
                }

                if (typeStr == "object")
                {
                    // Check if it has properties (it's a complex type)
                    if (propertySchema.TryGetProperty("properties", out var props))
                    {
                        // This is a nested type - for payloads, we'll use a descriptive name
                        if (propertyName.Equals("Payload", StringComparison.OrdinalIgnoreCase))
                        {
                            // Return a generic payload record type
                            // We'll enhance this later to generate nested records
                            return "object";
                        }
                        return "object";
                    }
                    return "object";
                }
                else if (typeStr == "string")
                {
                    if (propertySchema.TryGetProperty("format", out var format))
                    {
                        var formatStr = format.GetString();
                        if (formatStr == "uuid") return isNullable ? "System.Guid?" : "System.Guid";
                        if (formatStr == "date-time") return isNullable ? "System.DateTimeOffset?" : "System.DateTimeOffset";
                        if (formatStr == "email") return isNullable ? "string?" : "string";
                    }
                    return isNullable ? "string?" : "string";
                }
                else if (typeStr == "number")
                {
                    return isNullable ? "double?" : "double";
                }
                else if (typeStr == "integer")
                {
                    return isNullable ? "int?" : "int";
                }
                else if (typeStr == "boolean")
                {
                    return isNullable ? "bool?" : "bool";
                }
                else if (typeStr == "array")
                {
                    if (propertySchema.TryGetProperty("items", out var items))
                    {
                        var itemType = GetCSharpType(items);
                        return $"System.Collections.Generic.IReadOnlyList<{itemType}>";
                    }
                    return "System.Collections.Generic.IReadOnlyList<object>";
                }
            }

            return "object";
        }

        private string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input)) return input;

            // Handle kebab-case and snake_case
            if (input.Contains('-') || input.Contains('_'))
            {
                var words = input.Split(new[] { '-', '_' }, StringSplitOptions.RemoveEmptyEntries);
                return string.Join("", words.Select(w =>
                    CultureInfo.InvariantCulture.TextInfo.ToTitleCase(w.ToLower())));
            }

            // Handle camelCase - just capitalize the first letter
            return char.ToUpper(input[0]) + input.Substring(1);
        }

        private string GetClassName(string filePath)
        {
            var baseName = Path.GetFileNameWithoutExtension(filePath);
            return CultureInfo.InvariantCulture.TextInfo.ToTitleCase(baseName.Replace('-', ' ')).Replace(" ", "");
        }
    }
}
